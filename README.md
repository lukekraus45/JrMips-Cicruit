Luke Kraus
lek81@pitt.edu

Overview:
For this project we were to create a jrMips processor that would be able to take instructions and impliment them. To start this project I was able to take a lot of what we had from previous labs to get started. I began with creating the ALU that would be used. I had to do some modifications to it like adding the nor rather than the OR that we had before. I also added the "zero" output to it. This was used for the branch control. By having this I was able to check if the value was == 0 or not for 2 of the branch controls. After I had this work I moved on the registers. This was also mainly from the lab. I extended it out to 16 bits that would be used for the project. After I verified that this worked I began to make the main circuit. This was by far the most difficult part of the project. I looked closely at the slides from class which provided most of the reference for the layout of the circuit. After I had it assembled the way that I thought it should look I added the hex output as well as the LED bubble. After I had all of this I created the main control unit. This is the part that chose the muxes for the project. Most of these were easy and already in the slides. After I had all of this it was time to test the instructions. At this point I tried the li and halt instructions. After playing around with the values and seeing what allowed these to work and fail I was able to verify that they were working properly. I then moved onto the instructions in the ALU. All of these worked rather easily becuase most of the work was already done. I then moved onto the majority of the more difficult part of the project. The first of these instrucitons was the addi. This was not a partiularly difficult instruction, but checking for the immediate took me a while to understand. After I got the immediate value seperated and muxed out (via checking if the instruction was I or R) I was able to see get this instruction to work. The next group of instructions I implimented were the multiplication and division and mlo and mhi. These were also pretty easy for the most part. For these I added a mux and a mult/div control subcurcuit. This subcircuit looked to see if the mul or div instruction were called and if they were they chose the correct one. I added the premade multiplier and divider. The outputs of these were placed in either the hi or lo register which I had to add to the main circuit. For the mlo and mhi instructions I was able to just see which one was used (via control signals from a subcircuit) and then use that as the write data for whatever $rs register that was being written to. The next group of instructions that I looked at was the branch instructions. This group gave me some problems becuase I could not find out how exactly to impliment them. After really looking into it and visiting office hours I figured it out. So for this part I OR'd together the 4 different branch types (bn, bx, bz, bp). This meant that if any were one than the branch needed to take place. Then I connected the branch control signal to all of them, this meant that the instruction was a branch. I then created a branch control unit which looked at the 4 instructions and set the signal to 1 for each unique signal. (Ex. 0101 on the table would set bp to 1). Finally for the bx and bz I connected the 0 from the ALU to test if it was 0 or not. This setup all of the branch instructions. So if any of them were true than the branch would take place. The second to last instruction set that I looked at was jump. These were not very difficult either. For these I was able to just add a jump control unit which checked for the 3 different instructions. If it was a jump instruction than it took the immed. value and jumped to there. For the jal instruction I had to add the pc+1 as the write data and store that in the register. For the jr I had to look at the register for the value. This was all done through the conrol units for the subcircuits. Finally was the load store instrucitons. These were by far the most difficult for me. I had everything connected as the slides showed, but I just needed a mux. I could not see this myself at first, but after a while (and a lot of debugging) I was able to figure it out. For this I just had to add a mux and if it was a load store instruction I would select the mux value to load or store to/from. Then the value from the RAM would be written to the register for the load. After I finished implimenting all of the instruction I wrote few programs that tested these cases and instructions. Most of the worked fine with the exception of addi which gave me some issues becuase I did not account for the value in the register being >1 from the beginning so I was just doing a li at first rather than adding the values of the register and the immed. I had to switch a control signal on a mux and this problem was resolved rather painlessly. Overall, I was able to impliment all of the instructions and get the results I believe were correct. 

Unique aspects of my program:
I used a lot of tunnels and many different subcircuits. The tunnels allowed for me to label everything and be able to limit the number of wires used. I used so many subcircuits becuase it was easier to edit one single control unit rather than having to retype the values of the entire truth table. So when I had to change a value I could change it on just one unit rather than having to start over and re enter all of the values. This just saved me time even though it created more subciruits than I probably needed. I also added output pins in the bottom left so that I was able to see the values of everything. This was mainly used for debugging to see what value was of everything. It also was very useful for selecting the mux select bits as well. 

Bugs with my Program:
I do not think that there are any bugs. All of the instructions ran fine for me and gave the expected value. I tested most of the cases I could think of for the instructions, but there may be an extreme case that I did not think of. Other than that I belive my project is correct. 

Control units:
Although I am not going to explain each individual case becuase of redundency I will outline the basic ideas behind my control units. For almost all of them I just looked at the slides or came up with them by looking at the instructions. If it was a jump control signal than I looked at the opcode and whatever instructions were jump were marked with a 1 and the rest were 0's. This meant that the mux would only select the value when the instruction was a jump. This was the same for the branch instructions as well as load store. All of the control signals were set this way. And then I would test them and most of the time it would work fine. In a few cases the wrong value would be selected so I would either have to add another MUX or go back and change the value. 
